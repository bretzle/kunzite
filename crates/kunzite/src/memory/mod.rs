mod cartridge;
mod interrupt;
mod mbc;

use self::mbc::{Mbc, MbcType, RomOnly};
use crate::{audio::Audio, util::Color};

pub use cartridge::Cartridge;

const INITIAL_VALUES_FOR_FFXX: [u8; 0x100] = [
	0xCF, 0x00, 0x7E, 0xFF, 0xD3, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1,
	0x80, 0xBF, 0xF3, 0xFF, 0xBF, 0xFF, 0x3F, 0x00, 0xFF, 0xBF, 0x7F, 0xFF, 0x9F, 0xFF, 0xBF, 0xFF,
	0xFF, 0x00, 0x00, 0xBF, 0x77, 0xF3, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x71, 0x72, 0xD5, 0x91, 0x58, 0xBB, 0x2A, 0xFA, 0xCF, 0x3C, 0x54, 0x75, 0x48, 0xCF, 0x8F, 0xD9,
	0x91, 0x80, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x2B, 0x0B, 0x64, 0x2F, 0xAF, 0x15, 0x60, 0x6D, 0x61, 0x4E, 0xAC, 0x45, 0x0F, 0xDA, 0x92, 0xF3,
	0x83, 0x38, 0xE4, 0x4E, 0xA7, 0x6C, 0x38, 0x58, 0xBE, 0xEA, 0xE5, 0x81, 0xB4, 0xCB, 0xBF, 0x7B,
	0x59, 0xAD, 0x50, 0x13, 0x5E, 0xF6, 0xB3, 0xC1, 0xDC, 0xDF, 0x9E, 0x68, 0xD7, 0x59, 0x26, 0xF3,
	0x62, 0x54, 0xF8, 0x36, 0xB7, 0x78, 0x6A, 0x22, 0xA7, 0xDD, 0x88, 0x15, 0xCA, 0x96, 0x39, 0xD3,
	0xE6, 0x55, 0x6E, 0xEA, 0x90, 0x76, 0xB8, 0xFF, 0x50, 0xCD, 0xB5, 0x1B, 0x1F, 0xA5, 0x4D, 0x2E,
	0xB4, 0x09, 0x47, 0x8A, 0xC4, 0x5A, 0x8C, 0x4E, 0xE7, 0x29, 0x50, 0x88, 0xA8, 0x66, 0x85, 0x4B,
	0xAA, 0x38, 0xE7, 0x6B, 0x45, 0x3E, 0x30, 0x37, 0xBA, 0xC5, 0x31, 0xF2, 0x71, 0xB4, 0xCF, 0x29,
	0xBC, 0x7F, 0x7E, 0xD0, 0xC7, 0xC3, 0xBD, 0xCF, 0x59, 0xEA, 0x39, 0x01, 0x2E, 0x00, 0x69, 0x00,
];

const INITIAL_VALUES_FOR_COLOR_FFXX: [u8; 0x100] = [
	0xCF, 0x00, 0x7C, 0xFF, 0x44, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1,
	0x80, 0xBF, 0xF3, 0xFF, 0xBF, 0xFF, 0x3F, 0x00, 0xFF, 0xBF, 0x7F, 0xFF, 0x9F, 0xFF, 0xBF, 0xFF,
	0xFF, 0x00, 0x00, 0xBF, 0x77, 0xF3, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
	0x91, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x7E, 0xFF, 0xFE,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0xFF, 0xC1, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0xF8, 0xFF, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B, 0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D,
	0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E, 0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99,
	0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC, 0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E,
	0x45, 0xEC, 0x42, 0xFA, 0x08, 0xB7, 0x07, 0x5D, 0x01, 0xF5, 0xC0, 0xFF, 0x08, 0xFC, 0x00, 0xE5,
	0x0B, 0xF8, 0xC2, 0xCA, 0xF4, 0xF9, 0x0D, 0x7F, 0x44, 0x6D, 0x19, 0xFE, 0x46, 0x97, 0x33, 0x5E,
	0x08, 0xFF, 0xD1, 0xFF, 0xC6, 0x8B, 0x24, 0x74, 0x12, 0xFC, 0x00, 0x9F, 0x94, 0xB7, 0x06, 0xD5,
	0x40, 0x7A, 0x20, 0x9E, 0x04, 0x5F, 0x41, 0x2F, 0x3D, 0x77, 0x36, 0x75, 0x81, 0x8A, 0x70, 0x3A,
	0x98, 0xD1, 0x71, 0x02, 0x4D, 0x01, 0xC1, 0xFF, 0x0D, 0x00, 0xD3, 0x05, 0xF9, 0x00, 0x0B, 0x00,
];

pub struct Memory {
	mbc: Box<dyn Mbc>,
	wram: Vec<u8>,
	vram: Vec<u8>,
	hram: [u8; 0x100],
	oam: [u8; 0x100],

	joypad_state: u8,
	pub scan_line: u8,
	pub irq48_signal: u8,
	pub screen_disabled: bool,
	pub lcd_status_mode: u8,
	gpu_cycles: GpuCycles,
	pub div_cycles: i32,
	pub tima_cycles: i32,
	is_cgb: bool,
	vram_bank: i32,
	wram_bank: i32,
	hdma_source: u16,
	hdma_destination: u16,
	hdma_bytes: i32,
	hdma_enabled: bool,
	pub cgb_background_palettes: [[Color; 4]; 8],
	pub cgb_sprite_palettes: [[Color; 4]; 8],
	audio: Audio,
}

impl Memory {
	pub fn from_cartridge(cartridge: Cartridge, is_cgb: bool) -> Self {
		let hram = if is_cgb {
			INITIAL_VALUES_FOR_COLOR_FFXX
		} else {
			INITIAL_VALUES_FOR_FFXX
		};

		let mbc: Box<dyn Mbc> = match cartridge.get_mbc_type() {
			MbcType::RomOnly => Box::new(RomOnly::new(cartridge)),
			_ => panic!(),
		};

		let vram = if is_cgb {
			vec![0x00; 0x2000 * 2]
		} else {
			vec![0x00; 0x2000]
		};

		let wram = if is_cgb {
			vec![0x00; 0x1000 * 8]
		} else {
			vec![0x00; 0x1000 * 2]
		};

		let mut hdma_source = 0;
		let mut hdma_destination = 0;
		if is_cgb {
			// TODO: make all of these MMU constants
			let mut hdma_source_high = hram[0xFF51 - 0xFF00] as u16;
			let hdma_source_low = hram[0xFF52 - 0xFF00] as u16;
			if hdma_source_high > 0x7F && hdma_source_high < 0xA0 {
				hdma_source_high = 0;
			}
			hdma_source = (hdma_source_high << 8) | (hdma_source_low & 0xF0);
			let hdma_destination_high = hram[0xFF53 - 0xFF00] as u16;
			let hdma_destination_low = hram[0xFF54 - 0xFF00] as u16;
			hdma_destination =
				((hdma_destination_high & 0x1F) << 8) | (hdma_destination_low & 0xF0);
			hdma_destination |= 0x8000;
		}

		// setup initial values for the sound module
		let mut audio = Audio::new();
		// for i in 0xFF10..=0xFF3F {
		// 	let value = if is_cgb {
		// 		INITIAL_VALUES_FOR_COLOR_FFXX[i - 0xFF00]
		// 	} else {
		// 		INITIAL_VALUES_FOR_FFXX[i - 0xFF00]
		// 	};
		// 	audio.write_byte(i as u16, value);
		// }

		Self {
			mbc,
			vram,
			wram,
			hram,
			oam: [0; 0x100],
			scan_line: 144,
			joypad_state: 0,
			irq48_signal: 0,
			screen_disabled: false,
			lcd_status_mode: 1,
			gpu_cycles: GpuCycles::new(),
			div_cycles: 0,
			tima_cycles: 0,
			is_cgb,
			vram_bank: 0,
			wram_bank: 1,
			hdma_source,
			hdma_destination,
			hdma_bytes: 0,
			hdma_enabled: false,
			cgb_background_palettes: [[Color::WHITE; 4]; 8],
			cgb_sprite_palettes: [[Color::WHITE; 4]; 8],
			audio,
		}
	}

	pub fn read_byte(&self, index: u16) -> u8 {
		match index {
			0x0000..=0x7FFF => self.mbc.read_byte(index),
			0xA000..=0xBFFF => self.mbc.read_byte(index),
			_ => panic!("tried to read: {:04X}", index),
		}
	}

	pub fn write_byte(&mut self, index: u16, val: u8) {
		match index {
			0x0000..=0x7FFF => self.mbc.write_byte(index, val),
			0xA000..=0xBFFF => self.mbc.write_byte(index, val),
			_ => panic!("tried to write: {:04X}", index),
		}
	}

	pub fn read_word(&self, index: u16) -> u16 {
		let low = self.read_byte(index) as u16;
		let high = self.read_byte(index + 1) as u16;
		(high << 8) + low
	}

	pub fn write_word(&mut self, index: u16, value: u16) {
		let high = (value >> 8) as u8;
		let low = value as u8;
		self.write_byte(index, low);
		self.write_byte(index + 1, high);
	}
}

struct GpuCycles {}

impl GpuCycles {
	pub fn new() -> Self {
		Self {}
	}
}
